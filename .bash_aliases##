alias d='docker ' 
alias sudo='sudo '
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
alias lh='ls -lh'
alias vi='vim'
alias va='vagrant'
alias vgl='vagrant global-status'
alias vsh='vagrant ssh'
alias gst='git status'
alias gca='git commit -a'
alias gdc='git diff --cached'
alias dm='docker-machine'
alias dc='docker-compose'
alias dxi='docker exec -it'
alias dx='docker exec'
alias dps='docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}\t{{.Ports}}"'
alias pae='puppet agent -t --environment'
alias subl='subl3 -n'
alias tb='nc termbin.com 9999'
alias wee='tmux attach -d -t weechat'
alias dlook='docker run --rm -e LOOKER_CLIENT_ID -e LOOKER_CLIENT_SECRET -e LICENSE_USER -e LICENSE_PASS support/dlook'
# support dump reconsituters

# extract latest support dump to a dated directory and cd into it
# nuke useless dsinfo subdirs
splode ()
{
    CAPDIR_PREFIX="sd";
    SUPPORT_DUMP_PAT='docker-support*zip';
    if [ -z $1 ]; then
        source=$(ls -rt $SUPPORT_DUMP_PAT |tail -n1);
    else
        source=$1;
    fi;
    capdate=$(echo $source |cut -d- -f3);
    capdir=${CAPDIR_PREFIX}${capdate};
    mkdir $capdir;
    cd $capdir;
    ln -s ../$source .;
    unzip -qq *zip;
    for dir in */;
    do
        mv $dir/dsinfo/* $dir;
        rmdir $dir/dsinfo;
    done;
    ls -l
}

# NOTE: remainder of functions presume the useless $node/dsinfo/ dir has had
# its contents moved to $node/

# enhanced `docker node ls` from root of support dump
sd_nodes() {
    (echo HOSTNAME ID ROLE AVAIL STATE IP DAEMON DTR
        jq '.[] |
                [(.Description.Hostname // "none"),
                  .ID[0:10],
                  (if .ManagerStatus.Leader == true then "leader" else .Spec.Role end),
                  .Spec.Availability,
                  .Status.State,
                  (if .Status.Addr == "127.0.0.1" or .Status.Addr == "0.0.0.0" then .ManagerStatus.Addr else .Status.Addr end),
                  .Description.Engine.EngineVersion]
                  |@tsv' -r ucp-nodes.txt | sed 's/:2377//' | awk '{dtr=""; if(system("! ls " $1 "/inspect/dtr-* &>/dev/null")) {dtr="DTR"}; print $0,dtr}' | sort -k3,5 -k1,1V -s
    ) | column -t | sed '1{p;s/./-/g}'
}

# prints beginning and end of daemon logs. run from root of supportdumpc
sd_logspan() {
    for file in */journal*; do
        echo -n $file": "$(head -n3 $file |tail -n1 |cut -d' ' -f1-3)" -- "$(tail -n1 $file |cut -d ' ' -f1-3) $(grep -q level=debug $file && echo "(debug)")
        echo
    done | sort -t/ -k1,1 -s | column -t
}

# agent logs from the running ucp-agent task:
# expects to run from the host's directory
sd_agent_logs(){
    cat $(jq -r '.[]|select(.State.Status=="running")|input_filename|sub("inspect";"logs")|sub("txt";"log")' inspect/ucp-agent*)
}



train-dev() {
    set -l CURRENT_DIR $(pwd)
    cd ~/git/dockersupport/train
    docker build -t support/train .
    cd $CURRENT_DIR
    if [ -z $argv ]; then
        docker run --rm -ti --env-file='train.env' -v $(pwd):/host -v /Users/jbaker/git/dockersupport/train/train:/home/train/train support/train
    else
        docker run --rm -ti --env-file='train.env' -e VPC=$argv -v $(pwd):/host -v /Users/jbaker/git/dockersupport/train/train:/home/train/train support/train
    fi  
}

jps() {
   jq -r -M --arg key "$1" 'paths | select(.[-1]|strings|test($key;"i")) | [.[]|tostring] | join(".") | "." + .[2:]' | sort -u
}
